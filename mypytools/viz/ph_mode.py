"""visualize phonon modes"""

import pickle

import numpy
from ase import Atoms
from ase.build import make_supercell


def save_phonon_modes_for_viz(
    atoms: Atoms,
    ph_eigvec_list: list[numpy.ndarray],
    k_list: list[numpy.ndarray],
    other_data: dict = None,
    comment: str = "",
    fpath: str = None,
):
    """
    Save phonon modes data for visualization.
    This function saves phonon eigenvectors, corresponding k-points, and atomic structure
    to an PKL file for later visualization of phonon modes.
    Args:
        atoms (Atoms): Atomic structure object.
        ph_eigvec_list (list[numpy.ndarray]): List of phonon eigenvectors. Each eigenvector
            should be a 1D array of size 3*natoms representing displacement vectors for all atoms.
        k_list (list[numpy.ndarray]): List of k-points corresponding to each eigenvector.
            Each k-point should be a 1D array of size 3.
        other_data (dict, optional): Additional data to save in the PKL file, like energies and indices.
            Defaults to None.
        comment (str, optional): Comment to include with the saved data. Defaults to "".
        fpath (str, optional): File path where to save the PKL file. If None, a default name
            based on the number of modes will be used. Defaults to None.
    Raises:
        AssertionError: If ph_eigvec_list and k_list have different lengths.
        AssertionError: If eigenvector dimensions don't match the expected size (3*natoms).
        AssertionError: If k-points are not 3D vectors.
    Returns:
        str: The file path where the data was saved.
    Warning:
        This docstring is generated by LLM.
    """
    assert len(ph_eigvec_list) == len(k_list), "ph_eigvec_list and k_list must have the same length"
    assert 3*len(atoms) == ph_eigvec_list[0].size, (
        f"ph_eigvec_list[0] size should be (natoms * 3)=({3*len(atoms)}), but got {ph_eigvec_list[0].size}"
    )
    assert all([ph_eigvec.ndim == 1 for ph_eigvec in ph_eigvec_list])
    assert all([ph_eigvec.size == 3*len(atoms) for ph_eigvec in ph_eigvec_list])
    assert all([k.ndim == 1 for k in k_list])
    assert all([k.size == 3 for k in k_list])
    if fpath is None:
        fpath = f"phonon_modes_{len(ph_eigvec_list)}.pkl"
    data = {
        "atoms": atoms,
        "ph_eigvec_list": ph_eigvec_list,
        "k_list": k_list,
        "comment": comment,
    }
    if other_data is not None:
        assert isinstance(other_data, dict), "other_data should be a dictionary"
        data.update(other_data)
    else:
        pass

    with open(fpath, "wb") as f:
        pickle.dump(data, f)

    return fpath


def generate_phonon_realspace_displacements(
    atoms: Atoms,
    ph_eigvec: numpy.ndarray,
    k: numpy.ndarray,
    supercell: numpy.ndarray,
    num_frames: int = 16,
    amp_factor: float = 1.0,
    comment: str = "",
) -> list[Atoms]:
    """
    Generate phonon frames for visualization for postprocessing phonopy output for visualization.

    Warning:
        Only tested for Phonopy output!

    Note:
        The phonon eigenvectors should be like phonopy, i.e. bloch phase applied to each atom but not unit cell.

    Args:
        atoms (ase.atoms.Atoms): The atomic structure.
        ph_eigvec (numpy.ndarray): Phonon eigenvector, better from phonopy.
        k (numpy.ndarray): Wave vector contains the 2*pi factor.
        supercell (numpy.ndarray): Supercell transformation matrix.
        num_frames (int, optional): Number of frames to generate. Defaults to 16.
        amp_factor (float, optional): Amplitude scaling factor. Defaults to 1.0.
        comment (str, optional): Comment to add to each frame. Defaults to "".

    Returns:
        list: List of Atoms objects representing the frames.

    Usage:
    ```python
    atoms = read("structure.xyz")
    with h5py.File("phonopy.hdf5", "r") as f:  # extract the 0th k-path segment
        ph_kpath_frac = h5["path"][0, :]  # shape (nqpoints, 3)
        ph_freqs = h5["frequency"][0, :]  # shape (nqpoints, nbands)
        ph_eigvecs = h5["eigenvector"][0, :]  # shape (nqpoints, natoms*3, nbands)
    ph_kpath = ph_kpath_frac @ atoms.cell.reciprocal()  # without 2*pi factor
    kpt_idx, band_idx = 0, 0
    ph_frames = generate_phonon_visuals(
        atoms = atoms,
        ph_eigvec = ph_eigvecs[kpt_idx, :, band_idx],
        k = 2 * numpy.pi * ph_kpath[kpt_idx],
        supercell = numpy.diag([3, 3, 1]),  # build 3x3x1 supercell
        comment=f"seg=GK,kpt_idx={kpt_idx},band_idx={band_idx}",  # add comment
    )
    write("ph_frames.xyz", ph_frames)
    ```

    TODO:
        Double check and update the displacement equation

    Reference:
        Eq.27 in A. Togo, L. Chaput, T. Tadano, and I. Tanaka, Implementation strategies in phonopy and phono3py,
        J. Phys.: Condens. Matter 35, 353001 (2023).
        Eq.3.20 in Peter Brueesch, Phonons: Theory and Experiments
    """
    assert ph_eigvec.ndim == 1, f"ph_eigvec should be a 1D array, but got {ph_eigvec.ndim}D"
    assert (
        ph_eigvec.size == len(atoms) * 3
    ), f"ph_eigvec size should be (natoms * 3)=({len(atoms) * 3}), but got {ph_eigvec.size}"
    assert (
        supercell.ndim == 2 and supercell.shape[0] == supercell.shape[1] == 3
    ), f"supercell should be a 3x3 matrix, but got shape {supercell.shape}"

    # Generate the supercell
    supercell_atoms = make_supercell(atoms, supercell)
    sc_positions = supercell_atoms.get_positions()

    # Repeat phonon eigenvector for the supercell
    natoms = len(atoms)
    sc_eigvec = numpy.tile(ph_eigvec.reshape(natoms, 3), (len(supercell_atoms) // natoms, 1))  # shape (n_sc_atoms, xyz)

    # Apply Bloch phase correction for each atom in the supercell
    bloch_phase_factor = numpy.exp(1j * (sc_positions @ k))[:, None]  # shape (n_sc_atoms, 1)

    # Apply Bloch phase to eigenvector
    sc_eigvec = sc_eigvec * bloch_phase_factor

    # Compute phonon displacements
    ph_phase = numpy.angle(sc_eigvec)  # shape (n_sc_atoms, xyz)
    ph_amp = (
        amp_factor * numpy.abs(sc_eigvec) * (supercell_atoms.get_masses() ** (-0.5))[:, None]
    )  # shape (n_sc_atoms, xyz)
    ph_disp_time = numpy.linspace(0, 2 * numpy.pi, num_frames, endpoint=False)  # omega*t for one period, dont include endpoint

    # Calculate displacements for each frame
    ph_disp = ph_amp[None, :] * numpy.sin(
        ph_phase[None, :] + ph_disp_time[:, None, None]
    )  # shape (n_frames, n_sc_atoms, xyz)

    # Generate frames
    ph_frames = []
    for i in range(num_frames):
        this_atoms = supercell_atoms.copy()
        this_atoms.positions = sc_positions + ph_disp[i]
        this_atoms.info["comment"] = comment
        ph_frames.append(this_atoms)

    return ph_frames

generate_phonon_visuals = generate_phonon_realspace_displacements


def viz_gamma_ph_2d(
    atoms: Atoms,
    ph_eigvec: numpy.ndarray,
    arrow_scale: float = 10.0,
    ax=None,
    show_colorbar_title: bool = True,
):
    """
    Visualize gamma point phonon of 2D material.

    Parameters:
    -----------
    atoms : ASE Atoms object
        The atomic structure
    ph_eigvec : numpy.ndarray
        Phonon eigenvectors. Shape should be (n_atoms, 3) or (3*n_atoms,) or (n_atoms, 3, n_modes)
    arrow_scale : float, default=10.0
        Scaling factor for arrow lengths
    ax : matplotlib.axes.Axes, optional
        Axes to plot on. If None, creates new figure
    show_colorbar_title : bool, default=True
        Whether to show title for colorbar

    Returns:
    --------
    ax : matplotlib.axes.Axes
        The axes with the plot

    Notes:
    ------
    - Shows z-motion as arrow color using RdBu colormap (red=positive, blue=negative)
    - Shows x,y motion as arrows with lengths proportional to displacement
    - Arrow centers are positioned at atom locations
    - Different colors for atoms at different z-layers
    """
    import matplotlib.colors as mcolors
    import matplotlib.pyplot as plt

    # ========== Data Validation Assertions ==========
    assert hasattr(atoms, "positions"), "atoms must be an ASE Atoms object with positions attribute"
    assert hasattr(atoms, "__len__"), "atoms must have length (number of atoms)"
    assert isinstance(ph_eigvec, numpy.ndarray), "ph_eigvec must be a numpy array"
    assert len(atoms) > 0, "atoms object must contain at least one atom"
    assert arrow_scale > 0, "arrow_scale must be positive"
    assert numpy.isfinite(arrow_scale), "arrow_scale must be finite"

    # Get atom positions and validate
    atoms = atoms.copy()  # Ensure we don't modify original atoms object
    positions = atoms.positions
    n_atoms = len(atoms)
    assert positions.shape == (n_atoms, 3), f"positions shape {positions.shape} != (n_atoms={n_atoms}, 3)"
    assert numpy.all(numpy.isfinite(positions)), "All atomic positions must be finite"

    # ========== Handle Different Eigenvector Formats ==========
    if ph_eigvec.ndim == 1:
        # Flattened array: [x1,y1,z1,x2,y2,z2,...]
        assert len(ph_eigvec) == 3 * n_atoms, (
            f"Flattened ph_eigvec length {len(ph_eigvec)} != 3 * n_atoms ({3 * n_atoms})"
        )
        eigvec = ph_eigvec.reshape(n_atoms, 3)
    elif ph_eigvec.ndim == 2:
        assert ph_eigvec.shape == (n_atoms, 3), f"ph_eigvec shape {ph_eigvec.shape} != (n_atoms={n_atoms}, 3)"
        eigvec = ph_eigvec
    else:
        raise ValueError(f"ph_eigvec must be 1D or 2D array, got {ph_eigvec.ndim}D")

    assert numpy.all(numpy.isfinite(eigvec)), "All eigenvector components must be finite"
    assert eigvec.dtype == numpy.float64 or eigvec.dtype == numpy.float32, (
        f"eigvec dtype {eigvec.dtype} must be float64 or float32, got {eigvec.dtype}"
    )

    # ========== Extract Components Using Vectorization ==========
    x, y, z = positions.T  # Vectorized unumpy.cking
    ex, ey, ez = eigvec.T  # Displacement components

    # Create figure if needed
    if ax is None:
        ax = plt.gca()

    # Scale in-plane displacements for visualization
    ex_scaled = ex * arrow_scale
    ey_scaled = ey * arrow_scale

    # ========== Set Up Z-Component Colormap ==========
    ez_max = numpy.abs(ez).max()
    if ez_max > 1e-12:  # Avoid numerical issues
        # Use symmetric range around zero for proper color centering
        norm = mcolors.Normalize(vmin=-ez_max, vmax=ez_max)
    else:
        # Default range if no z motion
        norm = mcolors.Normalize(vmin=-1, vmax=1)
        print("Warning: No significant z-displacement detected")

    # cmap = plt.cm.RdBu_r  # Red-Blue colormap (red=positive, blue=negative)
    cmap = plt.cm.coolwarm  # Red-Blue colormap (red=positive, blue=negative)

    # ========== Plot Atomic Positions ==========
    ax.scatter(
        x, y, s=10, c="darkgray", marker=".", edgecolors=None, alpha=0.8, label="Atoms", zorder=1
    )

    # ========== Visualize Phonon Displacements ==========
    # Plot arrows for in-plane motion, colored by z-displacement
    quiver = ax.quiver(
        x,
        y,
        ex_scaled,
        ey_scaled,
        ez,
        cmap=cmap,
        norm=norm,
        scale_units="xy",
        scale=1,
        width=0.005,
        headwidth=3,
        headlength=4,
        alpha=0.9,
        zorder=3,
    )

    # Add colorbar
    cbar = plt.colorbar(quiver, ax=ax, shrink=0.8, pad=0.02)
    if show_colorbar_title:
        cbar.set_label("Z-displacement (relative units)", fontsize=11)
    cbar.ax.tick_params(labelsize=9)

    # ========== Calculate and Display Amplitude Statistics ==========
    # Use vectorized operations for amplitude calculations
    # amplitude_xyz = numpy.array([numpy.mean(numpy.abs(ex)), numpy.mean(numpy.abs(ey)), numpy.mean(numpy.abs(ez))])

    # max_amplitude = numpy.max(amplitude_xyz)
    # amplitude_ratio = amplitude_xyz / (max_amplitude + 1e-12)  # Avoid division by zero

    # ========== Format Plot ==========
    # Create informative title
    # title = "Gamma Point Phonon Mode Visualization\n"
    # title += f"Mean |amplitudes|: x={amplitude_xyz[0]:.4f}, y={amplitude_xyz[1]:.4f}, z={amplitude_xyz[2]:.4f}\n"
    # title += f"Amplitude ratios: x={amplitude_ratio[0]:.2f}, y={amplitude_ratio[1]:.2f}, z={amplitude_ratio[2]:.2f}"
    # ax.set_title(title, fontsize=10, pad=20)

    # Set equal aspect ratio and add grid
    # ax.grid(True, alpha=0.3, linewidth=0.5)
    # ax.tick_params(labelsize=10)

    # # ========== Validation of Results ==========
    # print(f"Visualization completed:")
    # print(f"  - {n_atoms} atoms plotted")
    # print(f"  - Max in-plane motion: {numpy.max(in_plane_magnitude):.4f}")
    # print(f"  - Max z-displacement: {ez_max:.4f}")
    # print(f"  - Arrow scaling factor: {arrow_scale}")

    ax.set_aspect("equal")

    return ax