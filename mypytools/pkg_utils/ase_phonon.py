"""
What you need for unfolding:
- primitive cell atoms object
- supercell transformation matrix for twisting
- force constant matrix C_N
    - for ase.phonons.Phonons object
    - calculation details: supercell, displacement
- band path in the primitive cell BZ

How to unfold:
```python

```
"""

from typing import Optional, Union

import ase
import numpy
from ase.build.supercells import lattice_points_in_supercell, make_supercell
from ase.phonons import Phonons
from tqdm import tqdm

from mypytools.viz.cell import visualize_cell_2d


def get_BZ_vectors(primitive_cell_vectors: numpy.ndarray):
    """equivalent to ase.Atoms.cell.reciprocal()"""
    pc_vecs = primitive_cell_vectors
    assert pc_vecs.shape == (3, 3)
    a1, a2, a3 = pc_vecs
    b1 = numpy.cross(a2, a3) / numpy.dot(a1, numpy.cross(a2, a3))
    b2 = numpy.cross(a3, a1) / numpy.dot(a2, numpy.cross(a3, a1))
    b3 = numpy.cross(a1, a2) / numpy.dot(a3, numpy.cross(a1, a2))
    return numpy.array([b1, b2, b3])


def align_pc_cell(pc_atoms: ase.Atoms, transformation_matrix: numpy.ndarray):
    """rotate the primitice cell, so that the first lattice vector of the output supercell is parallel to x-axis"""
    assert numpy.abs(pc_atoms.cell[2, :2]).sum() < 1e-10 and numpy.abs(pc_atoms.cell[:2, 2]).sum() < 1e-10, (
        "the input primitive cell be parallel to z-axis"
    )
    rot_angle_tan = make_supercell(pc_atoms, transformation_matrix, wrap=False).cell[0]  # take the first edge
    rot_angle = numpy.arctan2(rot_angle_tan[1], rot_angle_tan[0]) / numpy.pi * 180  # in degree
    pc_atoms = pc_atoms.copy()
    pc_atoms.rotate(-rot_angle, "z", rotate_cell=True)
    return pc_atoms


def get_sc_layer_to_pcsc(
    pc_atoms: ase.Atoms,
    sc_atoms: ase.Atoms,
    tranformation_matrix: numpy.ndarray,
    sc_layer_indices: numpy.ndarray,  # this layer for unfolding
    dist_threshold=1e-2,
):
    """
    We need to match the supercell generated by primitive cell with the supercell layer in the phonon calculation.
    This function is not well tested.
    Hereby I suggest we make sure the unfolding layer is the first half of the sc_atoms.
    """
    sc_layer_from_pc = make_supercell(pc_atoms, tranformation_matrix, wrap=False)
    sc_layer = sc_atoms[sc_layer_indices]
    dist = numpy.linalg.norm(sc_layer.positions[:, :2] - sc_layer_from_pc.positions[:, None, :2], axis=2)
    sc_indices_in_layer = numpy.where(dist < dist_threshold)[1]  # align atoms in sc_layer and sc_layer_from_pc
    layer_atoms_indices = sc_layer_indices[sc_indices_in_layer]  # value: atom in sc, position: atom in sc_layer_from_pc
    return layer_atoms_indices


def viz_sc_layers(
    pc_atoms: ase.Atoms,
    sc_atoms: ase.Atoms,
    tranformation_matrix: numpy.ndarray,
    layer_atoms_indices: numpy.ndarray,
    figsize=(10, 5),
    fontsize=6,
):
    """check the indices alignment by visualization"""
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(1, 2, figsize=figsize)
    sc_layer_from_pc = make_supercell(pc_atoms, tranformation_matrix, wrap=False)
    visualize_cell_2d(sc_layer_from_pc, ax=axes[0])
    for i, atom in enumerate(sc_layer_from_pc):
        axes[0].text(atom.x, atom.y, str(i), fontsize=fontsize, color="red")
    sc_layer = sc_atoms[layer_atoms_indices]
    visualize_cell_2d(sc_layer, ax=axes[1])
    for i, atom in enumerate(sc_layer):
        axes[1].text(atom.x, atom.y, str(i), fontsize=fontsize, color="red")
    fig = plt.gcf()
    return fig


def ase_phonons_load_fc(self: Phonons, C_N: numpy.ndarray, **kwargs):
    """construct a proper phonon object from force constant matrix"""
    self.C_N = C_N
    self.D_N = C_N.copy()

    # Add mass prefactor
    m_a = self.atoms.get_masses()
    self.m_inv_x = numpy.repeat(m_a[self.indices] ** -0.5, 3)
    M_inv = numpy.outer(self.m_inv_x, self.m_inv_x)
    for D in self.D_N:
        D *= M_inv


def gaussian_function(x: numpy.ndarray, mu: Union[int, numpy.ndarray] = 0, sigma: int = 1e-2):
    if isinstance(mu, int):
        pass  # return shape: x.shape
    elif isinstance(mu, numpy.ndarray):
        assert x.ndim == 1
        mu = mu[..., numpy.newaxis]  # shape (..., 1), return shape: mu.shape \otimes x.shape
    else:
        raise ValueError("mu should be int or numpy.ndarray, but got " + str(type(mu)))
    return numpy.exp(-((x - mu) ** 2) / (2 * sigma**2)) / (sigma * numpy.sqrt(2 * numpy.pi))


def band_expansion(energies: numpy.ndarray, grid: numpy.ndarray, sigma=1e-2):
    """expand the band structure to a grid by Gaussian function, i.e. add an extra"""
    grid_delta_min = numpy.min(numpy.diff(grid))
    if grid_delta_min > sigma:
        print(f"Warning: grid delta is smaller than sigma: {grid_delta_min:.3e} < {sigma:.3e}")
    return gaussian_function(grid, energies, sigma)  # shape (nbands, ngrids)


class UnfoldTwistBilayer:
    """
    Naming convention:
    - sc, pc: supercell, primitive cell
    - la, bz: lattice, reciprocal lattice
    - frac: fractional coordinates
        - frac_in_sc, frac_sc: fractional coordinates in supercell
    - tmat: transformation matrix
        - sc_cell = tmat @ pc_cell
    """

    def __init__(
        self,
        primitive_atoms: ase.Atoms,
        supercell_atoms: ase.Atoms,
        supercell_phonons: Phonons,
        layer_atoms_indices: numpy.ndarray,
        transformation_matrix: numpy.ndarray,
        kpts_frac_pc: numpy.ndarray,
        sc_wrap: bool = False,
        spatial_tol: float = 5e-2,
        verbose=False,
    ):
        """
        Note:
        """
        self.pc_atoms = primitive_atoms.copy()  # primcell atoms object
        self.pc_natoms = self.pc_atoms.get_global_number_of_atoms()
        # self.pc_atoms.wrap()
        self.sc_atoms = supercell_atoms.copy()  # supercell atoms object
        self.sc_natoms = self.sc_atoms.get_global_number_of_atoms()
        # self.sc_atoms.wrap()
        self.sc_ph = supercell_phonons  # supercell phonons object
        self.l_indices = layer_atoms_indices  # layer atoms indices in the supercell for unfolding
        self.sc_layer = self.sc_atoms[self.l_indices]  # the layer for unfolding
        self.sc_layer_natoms = len(self.sc_layer)
        # assert numpy.allclose(transformation_matrix, numpy.diag(numpy.diag(transformation_matrix))), \
        #     "only diagonal transformation matrix is supported"
        self.tmat = transformation_matrix  # transformation matrix, shape (3, 3)
        self.npcs_in_sc = numpy.linalg.det(self.tmat)
        print(self.npcs_in_sc)
        assert abs(self.npcs_in_sc - numpy.round(self.npcs_in_sc)) < 1e-10, (
            "transformation matrix determinant cannot be rounded as integer"
        )  # should be integer
        self.npcs_in_sc = int(self.npcs_in_sc)  # number of primcells in the supercell
        # test if the transformation matrix is correct
        _supercell_atoms_test = make_supercell(
            self.pc_atoms, self.tmat, wrap=sc_wrap
        )  # dependent on lattice_points_in_supercell()
        # print(_supercell_atoms_test.get_cell(), "\n", self.sc_layer.get_cell())
        # print(_supercell_atoms_test.get_cell() - self.sc_layer.get_cell())
        assert numpy.allclose(_supercell_atoms_test.get_cell(), self.sc_layer.get_cell(), atol=spatial_tol)
        # print(_supercell_atoms_test.get_positions()[:, :2] - self.sc_layer.get_positions()[:, :2])  # ensure the ordering
        """ you can turn off the following assertion if the atoms are wildly shaked """
        # assert numpy.allclose(
        #     _supercell_atoms_test.get_positions()[:, :2], self.sc_layer.get_positions()[:, :2], atol=spatial_tol
        # )  # ensure the ordering, but really hard to satisfy for twisted bilayers (strongly buckled)
        # TODO: add supercell atoms reordering
        self.kpts_frac_pc = kpts_frac_pc  # in pzBZ, fractional coordinates
        self.verbose = verbose

        self.prepare()

    def prepare(self):
        """(reciprocal) lattice vectors
        Relations:
        sc_la_vec = tmat @ pc_la_vec
        pc_bz_vec = tmat.T @ sc_bz_vec
        """
        # TODO: check why atoms.cell.reciprocal() returns the transposed inversion
        self.pc_la_vec = numpy.array(self.pc_atoms.get_cell())  # lattice vector, shape (3=la_vec, 3)
        self.pc_bz_vec = numpy.array(self.pc_atoms.cell.reciprocal())  # BZ vector, shape (3=bz_vec, 3)
        self.sc_la_vec = numpy.array(self.sc_atoms.get_cell())  # lattice vector, shape (3=la_vec, 3)
        self.sc_bz_vec = numpy.array(self.sc_atoms.cell.reciprocal())  # BZ vector, shape (3=bz_vec, 3)
        # print(self.sc_la_vec - self.tmat @ self.pc_la_vec)
        assert numpy.allclose(self.sc_la_vec, self.tmat @ self.pc_la_vec, atol=3e-2)
        # print(self.pc_bz_vec - self.tmat.T @ self.sc_bz_vec)
        assert numpy.allclose(self.pc_bz_vec, self.tmat.T @ self.sc_bz_vec, atol=3e-2)

        """pc lattice fractional shifts in the supercell"""
        self.pcs_shift_frac_in_sc = lattice_points_in_supercell(self.tmat)  # shape (self.npcs_in_sc, 3)
        # print(f"{self.pcs_shift_frac_in_sc=}")
        """int pc (in sc) displacements (along 3 lattice vectors)
        This is cruical for keeping the cell consistency (force constants matches the supercell)
        pcs_disp = supercells' primcells displacements in real space
                 =        pcs_shift_frac_in_sc @ sc_la_vec
                 = pcs_shift_frac_in_sc @ tmat @ inv(tmat) @ sc_la_vec  <-
                 =        pcs_shift_frac_in_pc @ pc_la_vec
                 =                pcs_disp_num @ pc_la_vec              <-
        """
        self.pcs_disp_num = numpy.round(self.pcs_shift_frac_in_sc @ self.tmat).astype(int)  # shape (self.npcs_in_sc, 3)
        # print(f"{self.pcs_disp_num=}")

        """sc bz fractional shifts in the pcBZ"""
        self.sc_bzs_shift_frac_in_pc_bz = lattice_points_in_supercell(self.tmat.T)  # shape (self.npcs_in_sc, 3)
        self.sc_bzs_disp_num = numpy.round(self.sc_bzs_shift_frac_in_pc_bz @ self.tmat.T).astype(
            int
        )  # shape (self.npcs_in_sc, 3)

        """fractional kpoints in scBZ of the pcBZ (self.kpts_frac_pc)
        k_pos = k-points in k-space
              = kpts_frac_pc @ pc_bz_vec
              = kpts_frac_pc @ tmat.T @ sc_bz_vec
              =          kpts_frac_sc @ sc_bz_vec
        """
        self.kpts_frac_sc = self.kpts_frac_pc @ self.tmat.T  # shape (nkpt, 3), simple conversion from pcBZ to scBZ
        # print(self.kpts_frac_pc @ self.pc_bz_vec - self.kpts_frac_sc @ self.sc_bz_vec)
        assert numpy.allclose(  # check consistency
            self.kpts_frac_pc @ self.pc_bz_vec, self.kpts_frac_sc @ self.sc_bz_vec, atol=1e-3
        )
        # self.kpts_frac_sc = numpy.mod(self.kpts_frac_sc, 1)  # wrap to [0, 1)  # not necessary

        """modes in bilayer for projection, slice for getting layer modes in bilayer modes"""
        self.layer_modes_indices = (3 * self.l_indices.reshape(-1, 1) + numpy.arange(3).reshape(1, 3)).reshape(
            -1
        )  # shape (3*self.sc_layer_natoms, )

    def solve_sc_ph(self, omega_arr: numpy.ndarray = None, modes_arr: numpy.ndarray = None):
        if omega_arr is None or modes_arr is None:
            omega_arr, modes_arr = self.sc_ph.band_structure(self.kpts_frac_sc, modes=True)
        """check shape consistency
        nbands = sc_n_atoms * 3
        omega_arr: shape (nkpt, nbands)
        modes_arr: shape (nkpt, nbands, natoms, 3)
        """
        nkpts = len(self.kpts_frac_sc)
        nbands = self.sc_natoms * 3
        assert omega_arr.shape == (nkpts, nbands)
        assert modes_arr.shape == (nkpts, nbands, self.sc_natoms, 3)
        modes_arr = modes_arr / numpy.linalg.norm(modes_arr, axis=(2, 3))[:, :, None, None]  # normalize by each band
        self.omega_arr, self.modes_arr = omega_arr, modes_arr

    def _cal_weights_one_kpt(self, kpt_idx: int):
        kpt_frac_pc = self.kpts_frac_pc[kpt_idx]  # shape (3,)
        kpt_frac_sc = self.kpts_frac_sc[kpt_idx]  # shape (3,)
        """construct primitive cell mode complete basis"""
        sc_nbands = self.sc_natoms * 3
        pc_nbands = self.pc_natoms * 3
        sc_layer_nbands = self.sc_layer_natoms * 3
        pc_modes = numpy.diag(numpy.ones(self.pc_natoms * 3))  # shape (pc_nbands, pc_nbands), rows as modes
        """expand from primcell to supercell
        question: why the phase is positive???? if I take negative then the weights are wrong
        """
        pc2sc_cells_phases = numpy.exp(
            -2.0j * numpy.pi * self.pcs_shift_frac_in_sc @ kpt_frac_sc
        )  # shape (self.npcs_in_sc, )
        # * self.pcs_disp_num @ kpt_frac_pc)  # shape (self.npcs_in_sc, ), the same
        pc2sc_modes = numpy.einsum("ij,m->imj", pc_modes, pc2sc_cells_phases).reshape(
            pc_nbands, sc_layer_nbands
        )  # i, m&j
        # pc2sc_modes = numpy.einsum(
        #     "ij,j->ij",
        #     numpy.hstack([pc_modes,]*self.npcs_in_sc),
        #     numpy.vstack([pc2sc_cells_phases,]*3*self.pc_natoms).T.reshape(-1),
        # )
        sc_modes = self.modes_arr[kpt_idx].reshape(sc_nbands, sc_nbands)[
            :, self.layer_modes_indices
        ]  # shape (sc_nbands, sc_layer_nbands)
        """ abs^2 then sum """
        weights = (
            numpy.abs(numpy.einsum("ij,kj->ik", pc2sc_modes.conj(), sc_modes)) ** 2
        )  # shape (pc_nbands, sc_nbands, )
        weights = weights.sum(axis=0)  # shape (sc_nbands, )
        # """ sum then abs^2, I think this is wrong """
        # weights = numpy.abs(numpy.einsum("ij,kj->k", pc2sc_modes.conj(), sc_modes))**2  # shape (sc_nbands, )
        return weights / self.npcs_in_sc  # normalize by the number of primcells in the supercell

    def cal_weights(self):
        weights = []
        for kpt_idx in tqdm(list(range(len(self.kpts_frac_sc)))):
            weights.append(self._cal_weights_one_kpt(kpt_idx))  # shape (sc_nbands)
        self.weights = numpy.stack(weights, axis=0)  # shape (nkpt, sc_nbands)

    def _cal_band_expansion(self, kpt_idx: int, grid: numpy.ndarray, sigma: float):
        weights = self.weights[kpt_idx]  # shape (sc_nbands, )
        sc_energies = self.omega_arr[kpt_idx]  # shape (sc_nbands, )
        sc_energies_expanded = band_expansion(energies=sc_energies, grid=grid, sigma=sigma)  # shape (sc_nbands, ngrid)
        proj_energies_expanded = numpy.einsum("j,jk->k", weights, sc_energies_expanded)  # shape (ngrid, )
        return proj_energies_expanded

    def cal_band_expansion(self, grid: Optional[numpy.ndarray] = None, sigma: float = 1e-2):
        if grid is None:
            # grid = numpy.linspace(0, 0.2, 201)
            grid = numpy.arange(0, 0.2001, 0.001)
        else:
            assert isinstance(grid, numpy.ndarray) and grid.ndim == 1
        energies_on_grid = []
        for kpt_idx in tqdm(list(range(len(self.kpts_frac_sc)))):
            energies_on_grid.append(self._cal_band_expansion(kpt_idx, grid, sigma))
        self.energies_on_grid = numpy.stack(energies_on_grid, axis=0)  # shape (nkpt, ngrid)
