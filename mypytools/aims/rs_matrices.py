"""FHI-aims real-space matrices parser for output_rs_matrices tag.

This module provides functionality to parse and process FHI-aims sparse matrix output
from the output_rs_matrices tag, including Hamiltonian and overlap matrices stored
in both HDF5 and text formats.
"""

import os
from typing import Optional

import h5py
import numpy
from scipy import sparse


class ParseRSMatrices:
    """Parser for FHI-aims real-space matrices from output_rs_matrices tag.

    This class handles loading and processing of sparse Hamiltonian and overlap
    matrices generated by FHI-aims with the output_rs_matrices tag. It supports
    both HDF5 and text file formats and provides methods to access matrices in
    dense or standard sparse (CSR) formats.

    Attributes:
        aims_dpath: Path to the directory containing FHI-aims output files.
        rs_hamiltonian: Loaded Hamiltonian matrix data (1D sparse format).
        rs_overlap: Loaded overlap matrix data (1D sparse format).
        matrix_size: Total number of matrix elements in sparse storage.
        n_cells: Number of unit cells in the Hamiltonian.
        n_basis: Number of basis functions per unit cell.
        cell_index: Cell indices array of shape (n_cells, 3).
        index_hamiltonian_1: Start indices for matrix rows.
        index_hamiltonian_2: End indices for matrix rows.
        column_index_hamiltonian: Column indices for sparse elements.
    """

    def __init__(
        self,
        aims_dpath: str,
        use_h5: bool = True,
    ) -> None:
        """Initialize the RS matrices parser.

        Args:
            aims_dpath: Path to directory containing FHI-aims output files.
            use_h5: If True, use HDF5 files; if False, use text files.

        Raises:
            AssertionError: If the specified directory does not exist.
            FileNotFoundError: If required files are not found in the directory.
        """
        assert os.path.isdir(aims_dpath), f"Directory {aims_dpath} does not exist."
        self.aims_dpath: str = aims_dpath
        self.rs_hamiltonian: Optional[numpy.ndarray] = None
        self.rs_overlap: Optional[numpy.ndarray] = None
        self.matrix_size: Optional[int] = None
        self.n_cells: Optional[int] = None
        self.n_basis: Optional[int] = None
        self.cell_index: Optional[numpy.ndarray] = None
        self.index_hamiltonian_1: Optional[numpy.ndarray] = None
        self.index_hamiltonian_2: Optional[numpy.ndarray] = None
        self.column_index_hamiltonian: Optional[numpy.ndarray] = None
        if use_h5:
            self.fnames = {
                "basis_indices": "basis-indices.out",
                "rs_indices": "rs_indices.out",
                "rs_hamiltonian": "rs_hamiltonian.h5",
                "rs_overlap": "rs_overlap.h5",
            }
        else:
            self.fnames = {
                "basis_indices": "basis-indices.out",
                "rs_indices": "rs_indices.out",
                "rs_hamiltonian": "rs_hamiltonian.out",
                "rs_overlap": "rs_overlap.out",
            }
        # Check if all required files exist
        for key, fname in self.fnames.items():
            fpath = os.path.join(self.aims_dpath, fname)
            if not os.path.exists(fpath):
                raise FileNotFoundError(f"Required file {fname} not found in {self.aims_dpath}")

        self._parse_rs_indices_out()

    def _extract_data_after_keyword(self, lines, keyword):
        """
        Extract data lines that come after a specific keyword until the next non-numeric section.

        Parameters:
        lines: list of strings - all lines from the file
        keyword: string - the keyword to search for

        Returns:
        list of strings - data lines after the keyword
        """
        data_lines = []
        found_keyword = False

        for line in lines:
            stripped = line.strip()

            if stripped == keyword:
                found_keyword = True
                continue

            if found_keyword:
                # Check if we hit another keyword (non-numeric line that's not just numbers)
                if stripped and not (stripped[0].isdigit() or stripped[0] == "-" or stripped[0].isspace()):
                    # Check if it's one of our known keywords
                    if any(
                        kw in stripped
                        for kw in [
                            "n_hamiltonian_matrix_size",
                            "n_cells_in_hamiltonian",
                            "n_basis",
                            "index_hamiltonian",
                            "column_index_hamiltonian",
                        ]
                    ):
                        break

                # Add numeric data lines
                if stripped and (stripped[0].isdigit() or stripped[0] == "-"):
                    data_lines.append(stripped)

        return data_lines

    def _parse_rs_indices_out(
        self,
    ):
        rs_indices_fname = os.path.join(self.aims_dpath, self.fnames["rs_indices"])
        with open(rs_indices_fname, "r") as f:
            lines = f.readlines()

        # Parse the first three parameters
        for line in lines:
            stripped = line.strip()
            if stripped.startswith("n_hamiltonian_matrix_size:"):
                self.matrix_size = int(stripped.split(":")[1].strip())
            elif stripped.startswith("n_cells_in_hamiltonian:"):
                self.n_cells = int(stripped.split(":")[1].strip())
            elif stripped.startswith("n_basis:"):
                self.n_basis = int(stripped.split(":")[1].strip())

        # Extract data sections using the class method
        self.cell_index = self._extract_data_after_keyword(lines, "cell_index")
        self.index_hamiltonian_1 = self._extract_data_after_keyword(lines, "index_hamiltonian(1,:,:)")
        self.index_hamiltonian_2 = self._extract_data_after_keyword(lines, "index_hamiltonian(2,:,:)")
        self.column_index_hamiltonian = self._extract_data_after_keyword(lines, "column_index_hamiltonian")
        # Convert cell_index to (n_cells, 3) int array
        self.cell_index = numpy.array([list(map(int, line.split())) for line in self.cell_index], dtype=int)
        assert self.cell_index.shape == (self.n_cells, 3), (
            f"cell_index shape {self.cell_index.shape} != expected ({self.n_cells}, 3)"
        )
        # Convert index_hamiltonian_1 to (n_cells, n_basis) int array
        self.index_hamiltonian_1 = numpy.array(
            [list(map(int, line.split())) for line in self.index_hamiltonian_1], dtype=int
        )
        assert self.index_hamiltonian_1.shape == (self.n_cells, self.n_basis), (
            f"index_hamiltonian_1 shape {self.index_hamiltonian_1.shape} != expected ({self.n_cells}, {self.n_basis})"
        )
        # Convert index_hamiltonian_2 to (n_cells, n_basis) int array
        self.index_hamiltonian_2 = numpy.array(
            [list(map(int, line.split())) for line in self.index_hamiltonian_2], dtype=int
        )
        assert self.index_hamiltonian_2.shape == (self.n_cells, self.n_basis), (
            f"index_hamiltonian_2 shape {self.index_hamiltonian_2.shape} != expected ({self.n_cells}, {self.n_basis})"
        )
        # Convert column_index_hamiltonian to (matrix_size,) int array
        self.column_index_hamiltonian = numpy.array(
            [int(line.split()[0]) for line in self.column_index_hamiltonian], dtype=int
        )
        assert self.column_index_hamiltonian.shape == (self.matrix_size,), (
            f"column_index_hamiltonian shape {self.column_index_hamiltonian.shape} != expected ({self.matrix_size},)"
        )

    def load_rs_hamiltonian_h5(self) -> numpy.ndarray:
        """Load Hamiltonian matrix data from HDF5 file.

        Returns:
            numpy.ndarray: Hamiltonian matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the HDF5 file does not exist.
            KeyError: If the 'sparse_matrix' dataset is not found in the file.
        """
        h5_path = os.path.join(self.aims_dpath, self.fnames["rs_hamiltonian"])
        with h5py.File(h5_path, "r") as h5f:
            self.rs_hamiltonian = numpy.array(h5f["sparse_matrix"][:], dtype=numpy.float64)
        return self.rs_hamiltonian

    def load_rs_overlap_h5(self) -> numpy.ndarray:
        """Load overlap matrix data from HDF5 file.

        Returns:
            numpy.ndarray: Overlap matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the HDF5 file does not exist.
            KeyError: If the 'sparse_matrix' dataset is not found in the file.
        """
        h5_path = os.path.join(self.aims_dpath, self.fnames["rs_overlap"])
        with h5py.File(h5_path, "r") as h5f:
            self.rs_overlap = numpy.array(h5f["sparse_matrix"][:], dtype=numpy.float64)
        return self.rs_overlap

    def load_rs_hamiltonian_txt(self) -> numpy.ndarray:
        """Load Hamiltonian matrix data from text file.

        Returns:
            numpy.ndarray: Hamiltonian matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the text file does not exist.
        """
        txt_path = os.path.join(self.aims_dpath, self.fnames["rs_hamiltonian"])
        self.rs_hamiltonian = numpy.loadtxt(txt_path, dtype=numpy.float64)
        return self.rs_hamiltonian

    def load_rs_overlap_txt(self) -> numpy.ndarray:
        """Load overlap matrix data from text file.

        Returns:
            numpy.ndarray: Overlap matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the text file does not exist.
        """
        txt_path = os.path.join(self.aims_dpath, self.fnames["rs_overlap"])
        self.rs_overlap = numpy.loadtxt(txt_path, dtype=numpy.float64)
        return self.rs_overlap

    def load_matrices(self) -> tuple[numpy.ndarray, numpy.ndarray]:
        """Load both Hamiltonian and overlap matrices based on the file format.

        Returns:
            tuple[numpy.ndarray, numpy.ndarray]: Hamiltonian and overlap matrices.
        """
        if self.fnames["rs_hamiltonian"].endswith(".h5"):
            hamiltonian = self.load_rs_hamiltonian_h5()
            overlap = self.load_rs_overlap_h5()
        else:
            hamiltonian = self.load_rs_hamiltonian_txt()
            overlap = self.load_rs_overlap_txt()
        return hamiltonian, overlap

    def _reconstruct_full_matrix(self, matrix_data: numpy.ndarray) -> numpy.ndarray:
        """Reconstruct full dense matrix from FHI-aims sparse format.

        This method handles the conversion from FHI-aims special sparse storage format
        to a full dense matrix. The FHI-aims format stores only the upper triangular
        parts and uses symmetry relationships for efficiency.

        Args:
            matrix_data: 1D array containing the sparse matrix elements.

        Returns:
            numpy.ndarray: Full dense matrix of shape (n_cells * n_basis, n_cells * n_basis).

        Note:
            - Converts FORTRAN 1-based indices to Python 0-based indices
            - Handles empty rows marked with (0, -1) in index_hamiltonian
            - Applies symmetry: matrix[i,j] = matrix[j,i] for symmetric matrices
        """
        # Total matrix dimension: n_cells * n_basis
        full_size = self.n_cells * self.n_basis
        matrix_full = numpy.zeros((full_size, full_size), dtype=numpy.float64)

        # Process each cell and basis combination (skip last cell which is sentinel)
        for i_cell in range(self.n_cells - 1):  # Skip last row as per FORTRAN convention
            for i_basis in range(self.n_basis):
                # Get row index in full matrix
                row_idx = i_cell * self.n_basis + i_basis

                # Get start and end indices for this row (FORTRAN 1-based)
                start_idx = self.index_hamiltonian_1[i_cell, i_basis]
                end_idx = self.index_hamiltonian_2[i_cell, i_basis]

                # Check for empty row marker (0, -1)
                if start_idx == 0 and end_idx == -1:
                    continue

                # Convert to Python 0-based indexing
                start_idx -= 1  # FORTRAN 1-based to Python 0-based
                end_idx -= 1  # FORTRAN inclusive end to Python exclusive end

                # Extract elements for this row
                if start_idx >= 0 and end_idx >= start_idx and end_idx < len(matrix_data):
                    row_elements = matrix_data[start_idx : end_idx + 1]  # Include end_idx
                    col_indices = self.column_index_hamiltonian[start_idx : end_idx + 1]

                    # Convert column indices from FORTRAN 1-based to Python 0-based
                    col_indices = col_indices - 1

                    # Fill matrix elements
                    for elem, col_idx in zip(row_elements, col_indices):
                        if 0 <= col_idx < full_size:
                            matrix_full[row_idx, col_idx] = elem
                            # For symmetric matrices, fill the symmetric element
                            if row_idx != col_idx:
                                matrix_full[col_idx, row_idx] = elem

        return matrix_full

    def get_hamiltonian_dense(self) -> numpy.ndarray:
        """Get Hamiltonian matrix in dense format.

        Returns:
            numpy.ndarray: Full dense Hamiltonian matrix.

        Note:
            Automatically loads the matrix data if not already loaded.
        """
        if self.rs_hamiltonian is None:
            if self.fnames["rs_hamiltonian"].endswith(".h5"):
                self.load_rs_hamiltonian_h5()
            else:
                self.load_rs_hamiltonian_txt()

        return self._reconstruct_full_matrix(self.rs_hamiltonian)

    def get_overlap_dense(self) -> numpy.ndarray:
        """Get overlap matrix in dense format.

        Returns:
            numpy.ndarray: Full dense overlap matrix.

        Note:
            Automatically loads the matrix data if not already loaded.
        """
        if self.rs_overlap is None:
            if self.fnames["rs_overlap"].endswith(".h5"):
                self.load_rs_overlap_h5()
            else:
                self.load_rs_overlap_txt()

        return self._reconstruct_full_matrix(self.rs_overlap)

    def _to_csr_matrix(self, matrix_data: numpy.ndarray) -> sparse.csr_matrix:
        """Convert FHI-aims sparse format to SciPy CSR format.

        Args:
            matrix_data: 1D array containing the sparse matrix elements.

        Returns:
            sparse.csr_matrix: Matrix in standard CSR format.
        """
        full_size = self.n_cells * self.n_basis
        row_indices = []
        col_indices = []
        data = []

        # Process each cell and basis combination (skip last cell which is sentinel)
        for i_cell in range(self.n_cells - 1):  # Skip last row as per FORTRAN convention
            for i_basis in range(self.n_basis):
                # Get row index in full matrix
                row_idx = i_cell * self.n_basis + i_basis

                # Get start and end indices for this row (FORTRAN 1-based)
                start_idx = self.index_hamiltonian_1[i_cell, i_basis]
                end_idx = self.index_hamiltonian_2[i_cell, i_basis]

                # Check for empty row marker (0, -1)
                if start_idx == 0 and end_idx == -1:
                    continue

                # Convert to Python 0-based indexing
                start_idx -= 1  # FORTRAN 1-based to Python 0-based
                end_idx -= 1  # FORTRAN inclusive end to Python exclusive end

                # Extract elements for this row
                if start_idx >= 0 and end_idx >= start_idx and end_idx < len(matrix_data):
                    row_elements = matrix_data[start_idx : end_idx + 1]  # Include end_idx
                    col_idx_vals = self.column_index_hamiltonian[start_idx : end_idx + 1]

                    # Convert column indices from FORTRAN 1-based to Python 0-based
                    col_idx_vals = col_idx_vals - 1

                    # Add elements to CSR data
                    for elem, col_idx in zip(row_elements, col_idx_vals):
                        if 0 <= col_idx < full_size:
                            row_indices.append(row_idx)
                            col_indices.append(col_idx)
                            data.append(elem)

                            # For symmetric matrices, add the symmetric element
                            if row_idx != col_idx:
                                row_indices.append(col_idx)
                                col_indices.append(row_idx)
                                data.append(elem)

        return sparse.csr_matrix((data, (row_indices, col_indices)), shape=(full_size, full_size), dtype=numpy.float64)

    def get_hamiltonian_csr(self) -> sparse.csr_matrix:
        """Get Hamiltonian matrix in CSR sparse format.

        Returns:
            sparse.csr_matrix: Hamiltonian matrix in CSR format.

        Note:
            Automatically loads the matrix data if not already loaded.
        """
        if self.rs_hamiltonian is None:
            if self.fnames["rs_hamiltonian"].endswith(".h5"):
                self.load_rs_hamiltonian_h5()
            else:
                self.load_rs_hamiltonian_txt()

        return self._to_csr_matrix(self.rs_hamiltonian)

    def get_overlap_csr(self) -> sparse.csr_matrix:
        """Get overlap matrix in CSR sparse format.

        Returns:
            sparse.csr_matrix: Overlap matrix in CSR format.

        Note:
            Automatically loads the matrix data if not already loaded.
        """
        if self.rs_overlap is None:
            if self.fnames["rs_overlap"].endswith(".h5"):
                self.load_rs_overlap_h5()
            else:
                self.load_rs_overlap_txt()

        return self._to_csr_matrix(self.rs_overlap)
