"""FHI-aims matrix parsers for various output tags.

This module provides functionality to parse and process FHI-aims matrix output from:
- output_rs_matrices tag: Real-space sparse matrices (Hamiltonian and overlap) stored
  in both HDF5 and text formats
- output_h_s_matrices tag: Gamma-point Hamiltonian and overlap matrices stored as
  coordinate-value pairs in text format
"""

import glob
import json
import os
from typing import Optional

import h5py
import numpy
from ase.io import read
from scipy import sparse


class ParseRSMatrices:
    """Parser for FHI-aims real-space matrices from output_rs_matrices tag.

    This class handles loading and processing of sparse Hamiltonian and overlap
    matrices generated by FHI-aims with the output_rs_matrices tag. It supports
    both HDF5 and text file formats and provides methods to access matrices in
    dense or standard sparse (CSR) formats.

    Example:
    ```python
    rs_mat = ParseRSMatrices("path/to/aims/output")
    mat_h = rs_mat.get_hamiltonian_kspace([0.0, 0.0, 0.0])
    mat_s = rs_mat.get_overlap_kspace([0.0, 0.0, 0.0])
    eigvals, eigvecs = scipy.linalg.eigh(mat_h, mat_s)  # in Hartree and without chemical potential shift
    ```

    Attributes:
        aims_dpath: Path to the directory containing FHI-aims output files.
        rs_hamiltonian: Loaded Hamiltonian matrix data (1D sparse format).
        rs_overlap: Loaded overlap matrix data (1D sparse format).
        matrix_size: Total number of matrix elements in sparse storage.
        n_cells: Number of unit cells in the Hamiltonian.
        n_basis: Number of basis functions per unit cell.
        cell_index: Cell indices array of shape (n_cells, 3).
        index_hamiltonian_1: Start indices for matrix rows.
        index_hamiltonian_2: End indices for matrix rows.
        column_index_hamiltonian: Column indices for sparse elements.
    """

    def __init__(
        self,
        aims_dpath: str,
        use_h5: bool = True,
        use_cache: bool = True,
        cache_dir: Optional[str] = None,
    ) -> None:
        """Initialize the RS matrices parser.

        Args:
            aims_dpath: Path to directory containing FHI-aims output files.
            use_h5: If True, use HDF5 files; if False, use text files.
            use_cache: If True, enable automatic CSR matrix caching for performance.
            cache_dir: Directory for cache files. If None, uses aims_dpath.

        Raises:
            AssertionError: If the specified directory does not exist.
            FileNotFoundError: If required files are not found in the directory.
        """
        assert os.path.isdir(aims_dpath), f"Directory {aims_dpath} does not exist."
        self.aims_dpath: str = aims_dpath
        self.use_cache: bool = use_cache
        self.cache_dir: str = cache_dir if cache_dir is not None else aims_dpath
        self.rs_hamiltonian: Optional[numpy.ndarray] = None
        self.rs_overlap: Optional[numpy.ndarray] = None
        self.matrix_size: Optional[int] = None
        self.n_cells: Optional[int] = None
        self.n_basis: Optional[int] = None
        self.cell_index: Optional[numpy.ndarray] = None
        self.index_hamiltonian_1: Optional[numpy.ndarray] = None
        self.index_hamiltonian_2: Optional[numpy.ndarray] = None
        self.column_index_hamiltonian: Optional[numpy.ndarray] = None
        self.lattice_vectors: Optional[numpy.ndarray] = None
        if use_h5:
            self.fnames = {
                "basis_indices": "basis-indices.out",
                "rs_indices": "rs_indices.out",
                "rs_hamiltonian": "rs_hamiltonian.h5",
                "rs_overlap": "rs_overlap.h5",
            }
        else:
            self.fnames = {
                "basis_indices": "basis-indices.out",
                "rs_indices": "rs_indices.out",
                "rs_hamiltonian": "rs_hamiltonian.out",
                "rs_overlap": "rs_overlap.out",
            }
        # Check if all required files exist
        for key, fname in self.fnames.items():
            fpath = os.path.join(self.aims_dpath, fname)
            if not os.path.exists(fpath):
                raise FileNotFoundError(f"Required file {fname} not found in {self.aims_dpath}")

        self._parse_rs_indices_out()
        self._parse_geometry_in()

    def _extract_data_after_keyword(self, lines, keyword):
        """
        Extract data lines that come after a specific keyword until the next non-numeric section.

        Parameters:
        lines: list of strings - all lines from the file
        keyword: string - the keyword to search for

        Returns:
        list of strings - data lines after the keyword
        """
        data_lines = []
        found_keyword = False

        for line in lines:
            stripped = line.strip()

            if stripped == keyword:
                found_keyword = True
                continue

            if found_keyword:
                # Check if we hit another keyword (non-numeric line that's not just numbers)
                if stripped and not (stripped[0].isdigit() or stripped[0] == "-" or stripped[0].isspace()):
                    # Check if it's one of our known keywords
                    if any(
                        kw in stripped
                        for kw in [
                            "n_hamiltonian_matrix_size",
                            "n_cells_in_hamiltonian",
                            "n_basis",
                            "index_hamiltonian",
                            "column_index_hamiltonian",
                        ]
                    ):
                        break

                # Add numeric data lines
                if stripped and (stripped[0].isdigit() or stripped[0] == "-"):
                    data_lines.append(stripped)

        return data_lines

    def _parse_rs_indices_out(
        self,
    ):
        rs_indices_fname = os.path.join(self.aims_dpath, self.fnames["rs_indices"])
        with open(rs_indices_fname) as f:
            lines = f.readlines()

        # Parse the first three parameters
        for line in lines:
            stripped = line.strip()
            if stripped.startswith("n_hamiltonian_matrix_size:"):
                self.matrix_size = int(stripped.split(":")[1].strip())
            elif stripped.startswith("n_cells_in_hamiltonian:"):
                self.n_cells = int(stripped.split(":")[1].strip())
            elif stripped.startswith("n_basis:"):
                self.n_basis = int(stripped.split(":")[1].strip())

        # Extract data sections using the class method
        self.cell_index = self._extract_data_after_keyword(lines, "cell_index")
        self.index_hamiltonian_1 = self._extract_data_after_keyword(lines, "index_hamiltonian(1,:,:)")
        self.index_hamiltonian_2 = self._extract_data_after_keyword(lines, "index_hamiltonian(2,:,:)")
        self.column_index_hamiltonian = self._extract_data_after_keyword(lines, "column_index_hamiltonian")
        # Convert cell_index to (n_cells, 3) int array
        self.cell_index = numpy.array([list(map(int, line.split())) for line in self.cell_index], dtype=int)
        assert self.cell_index.shape == (self.n_cells, 3), (
            f"cell_index shape {self.cell_index.shape} != expected ({self.n_cells}, 3)"
        )
        # Convert index_hamiltonian_1 to (n_cells, n_basis) int array
        self.index_hamiltonian_1 = numpy.array(
            [list(map(int, line.split())) for line in self.index_hamiltonian_1], dtype=int
        )
        assert self.index_hamiltonian_1.shape == (self.n_cells, self.n_basis), (
            f"index_hamiltonian_1 shape {self.index_hamiltonian_1.shape} != expected ({self.n_cells}, {self.n_basis})"
        )
        # Convert index_hamiltonian_2 to (n_cells, n_basis) int array
        self.index_hamiltonian_2 = numpy.array(
            [list(map(int, line.split())) for line in self.index_hamiltonian_2], dtype=int
        )
        assert self.index_hamiltonian_2.shape == (self.n_cells, self.n_basis), (
            f"index_hamiltonian_2 shape {self.index_hamiltonian_2.shape} != expected ({self.n_cells}, {self.n_basis})"
        )
        # Convert column_index_hamiltonian to (matrix_size,) int array
        self.column_index_hamiltonian = numpy.array(
            [int(line.split()[0]) for line in self.column_index_hamiltonian], dtype=int
        )
        assert self.column_index_hamiltonian.shape == (self.matrix_size,), (
            f"column_index_hamiltonian shape {self.column_index_hamiltonian.shape} != expected ({self.matrix_size},)"
        )

    def _parse_geometry_in(self) -> None:
        """Parse geometry.in file to extract lattice vectors using ASE.

        Uses ASE to read the geometry file and extract the unit cell.
        Each row of the resulting array is a lattice vector.

        Raises:
            FileNotFoundError: If geometry.in file is not found.
            Exception: If ASE fails to read the geometry file.
        """
        geometry_path = os.path.join(self.aims_dpath, "geometry.in")

        if not os.path.exists(geometry_path):
            raise FileNotFoundError(f"geometry.in file not found in {self.aims_dpath}")

        try:
            atoms = read(geometry_path, format="aims")
            self.lattice_vectors = numpy.array(atoms.cell, dtype=numpy.float64)  # Shape: (3, 3)
        except Exception as e:
            raise Exception(f"Failed to parse geometry.in using ASE: {e}") from e

    def _generate_cache_filename(self, matrix_type: str, custom_filename: Optional[str] = None) -> str:
        """Generate cache filename for CSR matrices.

        Args:
            matrix_type: Either 'hamiltonian' or 'overlap'.
            custom_filename: Custom filename. If None, generates default name.

        Returns:
            str: Full path to cache file.

        Raises:
            ValueError: If matrix_type is not supported.
        """
        if matrix_type not in ["hamiltonian", "overlap"]:
            raise ValueError(f"matrix_type must be 'hamiltonian' or 'overlap', got {matrix_type}")

        if custom_filename is not None:
            # Use custom filename, ensure .npz extension
            cache_name = custom_filename if custom_filename.endswith(".npz") else f"{custom_filename}.npz"
        else:
            # Generate default filename based on source file
            source_key = f"rs_{matrix_type}"
            source_file = self.fnames[source_key]
            # Remove extension and add _csr.npz
            base_name = os.path.splitext(source_file)[0]
            cache_name = f"{base_name}_csr.npz"

        return os.path.join(self.cache_dir, cache_name)

    def _is_cache_valid(self, cache_file: str, source_file: str) -> bool:
        """Check if cache file is valid (newer than source file).

        Args:
            cache_file: Path to cache file.
            source_file: Path to source file.

        Returns:
            bool: True if cache is valid, False otherwise.
        """
        if not os.path.exists(cache_file):
            return False

        if not os.path.exists(source_file):
            return False

        cache_mtime = os.path.getmtime(cache_file)
        source_mtime = os.path.getmtime(source_file)

        return cache_mtime >= source_mtime

    def _load_csr_if_exists(self, cache_file: str, source_file: str) -> Optional[sparse.csr_matrix]:
        """Load CSR matrix from cache if valid.

        Args:
            cache_file: Path to cache file.
            source_file: Path to source file.

        Returns:
            sparse.csr_matrix or None: Cached matrix if valid, None otherwise.
        """
        if not self.use_cache:
            return None

        if not self._is_cache_valid(cache_file, source_file):
            return None

        try:
            return sparse.load_npz(cache_file)
        except Exception:
            # Cache file corrupted, remove it
            try:
                os.remove(cache_file)
            except OSError:
                pass
            return None

    def _calculate_phase_factors(self, k_frac: list) -> numpy.ndarray:
        """Calculate phase factors for Fourier transformation.

        Computes exp(2πi * k · R) for each cell, where k is the k-vector
        in fractional coordinates and R is the cell position vector.

        Args:
            k_frac: k-vector in fractional Brillouin zone coordinates [k₁, k₂, k₃].

        Returns:
            numpy.ndarray: Complex phase factors of shape (n_valid_cells,).

        Note:
            Excludes the last sentinel cell which has indices (999999999, 999999999, 999999999).
        """
        k_frac = numpy.array(k_frac, dtype=numpy.float64)

        if k_frac.shape != (3,):
            raise ValueError(f"k_frac must be a 3-element array, got shape {k_frac.shape}")

        # Skip last cell (sentinel with large indices)
        valid_cells = self.cell_index[:-1]  # Shape: (n_cells-1, 3)

        # Calculate k · R for each cell: dot product along last axis
        k_dot_R = numpy.dot(valid_cells, k_frac)  # Shape: (n_valid_cells,)

        # Calculate phase factors: exp(2πi * k · R)
        phase = numpy.exp(2j * numpy.pi * k_dot_R)

        return phase

    def _fourier_transform_from_U(self, U_matrix: numpy.ndarray, phase: numpy.ndarray) -> numpy.ndarray:
        """Transform U matrix to k-space using phase factors.

        Takes the real-space U matrix and applies Fourier transformation
        using the provided phase factors to obtain the k-space matrix.

        Args:
            U_matrix: Real-space U matrix of shape (n_cells * n_basis, n_basis).
            phase: Complex phase factors of shape (n_valid_cells,).

        Returns:
            numpy.ndarray: Complex k-space matrix of shape (n_basis, n_basis).

        Note:
            Uses vectorized operations with broadcasting for efficiency.
            The transformation follows: H(k) = Σ_R H(R) * exp(ik·R)
        """
        n_valid_cells = len(phase)  # n_cells - 1 (exclude sentinel)

        # Reshape U matrix: (n_cells * n_basis, n_basis) → (n_cells, n_basis, n_basis)
        U_reshaped = U_matrix[: n_valid_cells * self.n_basis].reshape(n_valid_cells, self.n_basis, self.n_basis)

        # Apply phase factors and sum over cells using broadcasting
        # phase[:, None, None] expands to (n_cells, 1, 1)
        # U_reshaped has shape (n_cells, n_basis, n_basis)
        # Broadcasting gives (n_cells, n_basis, n_basis)
        k_matrix = numpy.sum(U_reshaped * phase[:, None, None], axis=0)

        return k_matrix.astype(numpy.complex128)

    def load_rs_hamiltonian_h5(self) -> numpy.ndarray:
        """Load Hamiltonian matrix data from HDF5 file.

        Returns:
            numpy.ndarray: Hamiltonian matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the HDF5 file does not exist.
            KeyError: If the 'sparse_matrix' dataset is not found in the file.
        """
        h5_path = os.path.join(self.aims_dpath, self.fnames["rs_hamiltonian"])
        with h5py.File(h5_path, "r") as h5f:
            self.rs_hamiltonian = numpy.array(h5f["sparse_matrix"][:], dtype=numpy.float64)
        return self.rs_hamiltonian

    def load_rs_overlap_h5(self) -> numpy.ndarray:
        """Load overlap matrix data from HDF5 file.

        Returns:
            numpy.ndarray: Overlap matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the HDF5 file does not exist.
            KeyError: If the 'sparse_matrix' dataset is not found in the file.
        """
        h5_path = os.path.join(self.aims_dpath, self.fnames["rs_overlap"])
        with h5py.File(h5_path, "r") as h5f:
            self.rs_overlap = numpy.array(h5f["sparse_matrix"][:], dtype=numpy.float64)
        return self.rs_overlap

    def load_rs_hamiltonian_txt(self) -> numpy.ndarray:
        """Load Hamiltonian matrix data from text file.

        Returns:
            numpy.ndarray: Hamiltonian matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the text file does not exist.
        """
        txt_path = os.path.join(self.aims_dpath, self.fnames["rs_hamiltonian"])
        self.rs_hamiltonian = numpy.loadtxt(txt_path, dtype=numpy.float64)
        return self.rs_hamiltonian

    def load_rs_overlap_txt(self) -> numpy.ndarray:
        """Load overlap matrix data from text file.

        Returns:
            numpy.ndarray: Overlap matrix elements as 1D array of shape (matrix_size,).

        Raises:
            FileNotFoundError: If the text file does not exist.
        """
        txt_path = os.path.join(self.aims_dpath, self.fnames["rs_overlap"])
        self.rs_overlap = numpy.loadtxt(txt_path, dtype=numpy.float64)
        return self.rs_overlap

    def load_matrices(self) -> tuple[numpy.ndarray, numpy.ndarray]:
        """Load both Hamiltonian and overlap matrices based on the file format.

        Returns:
            tuple[numpy.ndarray, numpy.ndarray]: Hamiltonian and overlap matrices.
        """
        if self.fnames["rs_hamiltonian"].endswith(".h5"):
            hamiltonian = self.load_rs_hamiltonian_h5()
            overlap = self.load_rs_overlap_h5()
        else:
            hamiltonian = self.load_rs_hamiltonian_txt()
            overlap = self.load_rs_overlap_txt()
        return hamiltonian, overlap

    def _reconstruct_full_matrix(self, matrix_data: numpy.ndarray) -> numpy.ndarray:
        """Reconstruct dense matrix from FHI-aims sparse format.

        This method converts from FHI-aims sparse storage format to a dense matrix.
        The FHI-aims format stores matrix elements using compressed storage with
        row and column index arrays.

        Args:
            matrix_data: 1D array containing the sparse matrix elements.

        Returns:
            numpy.ndarray: Dense matrix of shape (n_cells * n_basis, n_basis).
            This represents the U matrix where each row corresponds to
            interactions between a (cell, basis) pair and all basis functions
            in the reference cell. The "U" here is in the sense of FORTRAN, and
            in Python it is "L".

        Note:
            - Converts FORTRAN 1-based indices to Python 0-based indices
            - Handles empty rows marked with (0, -1) in index arrays
            - Skips the last sentinel cell with large index values
        """
        # Matrix dimensions: rows = n_cells * n_basis, columns = n_basis
        n_rows = self.n_cells * self.n_basis
        matrix_full = numpy.zeros((n_rows, self.n_basis), dtype=numpy.float64)

        # Process each cell and basis combination (skip last cell which is sentinel)
        for i_cell in range(self.n_cells - 1):  # Skip last row as per FORTRAN convention
            for i_basis in range(self.n_basis):
                # Get row index in full matrix
                row_idx = i_cell * self.n_basis + i_basis

                # Get start and end indices for this row (FORTRAN 1-based)
                start_idx = self.index_hamiltonian_1[i_cell, i_basis]
                end_idx = self.index_hamiltonian_2[i_cell, i_basis]

                # Check for empty row marker (0, -1)
                if start_idx == 0 and end_idx == -1:
                    continue

                # Convert to Python 0-based indexing
                start_idx -= 1  # FORTRAN 1-based to Python 0-based
                end_idx -= 1  # FORTRAN inclusive end to Python exclusive end

                # Extract elements for this row
                if start_idx >= 0 and end_idx >= start_idx and end_idx < len(matrix_data):
                    row_elements = matrix_data[start_idx : end_idx + 1]  # Include end_idx
                    col_indices = self.column_index_hamiltonian[start_idx : end_idx + 1]

                    # Convert column indices from FORTRAN 1-based to Python 0-based
                    col_indices = col_indices - 1

                    # Fill matrix elements
                    for elem, col_idx in zip(row_elements, col_indices):
                        if 0 <= col_idx < self.n_basis:
                            matrix_full[row_idx, col_idx] = elem

        return matrix_full

    def get_hamiltonian_dense_U(self) -> numpy.ndarray:
        """Get Hamiltonian U matrix in dense format.

        This returns the stored upper block matrix representing interactions
        between all (cell, basis) pairs and the reference cell basis functions.
        This is the direct reconstruction of the stored FHI-aims sparse data.

        Returns:
            numpy.ndarray: U matrix of shape (n_cells * n_basis, n_basis).
            "U" for FORTRAN and "L" for Python.

        Note:
            Automatically loads the matrix data if not already loaded.
        """
        if self.rs_hamiltonian is None:
            if self.fnames["rs_hamiltonian"].endswith(".h5"):
                self.load_rs_hamiltonian_h5()
            else:
                self.load_rs_hamiltonian_txt()

        return self._reconstruct_full_matrix(self.rs_hamiltonian)

    def get_overlap_dense_U(self) -> numpy.ndarray:
        """Get overlap U matrix in dense format.

        This returns the stored upper block matrix representing overlap
        between all (cell, basis) pairs and the reference cell basis functions.
        This is the direct reconstruction of the stored FHI-aims sparse data.

        Returns:
            numpy.ndarray: U matrix of shape (n_cells * n_basis, n_basis).
            "U" for FORTRAN and "L" for Python.

        Note:
            Automatically loads the matrix data if not already loaded.
        """
        if self.rs_overlap is None:
            if self.fnames["rs_overlap"].endswith(".h5"):
                self.load_rs_overlap_h5()
            else:
                self.load_rs_overlap_txt()

        return self._reconstruct_full_matrix(self.rs_overlap)

    def _to_csr_matrix(self, matrix_data: numpy.ndarray) -> sparse.csr_matrix:
        """Convert FHI-aims sparse format to SciPy CSR format.

        Args:
            matrix_data: 1D array containing the sparse matrix elements.

        Returns:
            sparse.csr_matrix: Matrix in standard CSR format with shape (n_cells * n_basis, n_basis).
        """
        n_rows = self.n_cells * self.n_basis
        row_indices = []
        col_indices = []
        data = []

        # Process each cell and basis combination (skip last cell which is sentinel)
        for i_cell in range(self.n_cells - 1):  # Skip last row as per FORTRAN convention
            for i_basis in range(self.n_basis):
                # Get row index in full matrix
                row_idx = i_cell * self.n_basis + i_basis

                # Get start and end indices for this row (FORTRAN 1-based)
                start_idx = self.index_hamiltonian_1[i_cell, i_basis]
                end_idx = self.index_hamiltonian_2[i_cell, i_basis]

                # Check for empty row marker (0, -1)
                if start_idx == 0 and end_idx == -1:
                    continue

                # Convert to Python 0-based indexing
                start_idx -= 1  # FORTRAN 1-based to Python 0-based
                end_idx -= 1  # FORTRAN inclusive end to Python exclusive end

                # Extract elements for this row
                if start_idx >= 0 and end_idx >= start_idx and end_idx < len(matrix_data):
                    row_elements = matrix_data[start_idx : end_idx + 1]  # Include end_idx
                    col_idx_vals = self.column_index_hamiltonian[start_idx : end_idx + 1]

                    # Convert column indices from FORTRAN 1-based to Python 0-based
                    col_idx_vals = col_idx_vals - 1

                    # Add elements to CSR data
                    for elem, col_idx in zip(row_elements, col_idx_vals):
                        if 0 <= col_idx < self.n_basis:
                            row_indices.append(row_idx)
                            col_indices.append(col_idx)
                            data.append(elem)

        return sparse.csr_matrix((data, (row_indices, col_indices)), shape=(n_rows, self.n_basis), dtype=numpy.float64)

    def get_hamiltonian_csr_U(self) -> sparse.csr_matrix:
        """Get Hamiltonian U matrix in CSR sparse format.

        This returns the stored upper block matrix representing interactions
        between all (cell, basis) pairs and the reference cell basis functions.

        Returns:
            sparse.csr_matrix: U matrix in CSR format with shape (n_cells * n_basis, n_basis).

        Note:
            Automatically loads the matrix data if not already loaded.
            Uses caching for improved performance on subsequent calls.
        """
        # Try to load from cache first
        if self.use_cache:
            cache_file = self._generate_cache_filename("hamiltonian")
            source_file = os.path.join(self.aims_dpath, self.fnames["rs_hamiltonian"])
            cached_matrix = self._load_csr_if_exists(cache_file, source_file)
            if cached_matrix is not None:
                return cached_matrix

        # Load from source if cache miss or disabled
        if self.rs_hamiltonian is None:
            if self.fnames["rs_hamiltonian"].endswith(".h5"):
                self.load_rs_hamiltonian_h5()
            else:
                self.load_rs_hamiltonian_txt()

        csr_matrix = self._to_csr_matrix(self.rs_hamiltonian)

        # Auto-save to cache if enabled
        if self.use_cache:
            try:
                os.makedirs(self.cache_dir, exist_ok=True)
                sparse.save_npz(cache_file, csr_matrix)
            except Exception:
                # Cache save failed, continue without caching
                pass

        return csr_matrix

    def get_overlap_csr_U(self) -> sparse.csr_matrix:
        """Get overlap U matrix in CSR sparse format.

        This returns the stored upper block matrix representing overlap
        between all (cell, basis) pairs and the reference cell basis functions.

        Returns:
            sparse.csr_matrix: U matrix in CSR format with shape (n_cells * n_basis, n_basis).

        Note:
            Automatically loads the matrix data if not already loaded.
            Uses caching for improved performance on subsequent calls.
        """
        # Try to load from cache first
        if self.use_cache:
            cache_file = self._generate_cache_filename("overlap")
            source_file = os.path.join(self.aims_dpath, self.fnames["rs_overlap"])
            cached_matrix = self._load_csr_if_exists(cache_file, source_file)
            if cached_matrix is not None:
                return cached_matrix

        # Load from source if cache miss or disabled
        if self.rs_overlap is None:
            if self.fnames["rs_overlap"].endswith(".h5"):
                self.load_rs_overlap_h5()
            else:
                self.load_rs_overlap_txt()

        csr_matrix = self._to_csr_matrix(self.rs_overlap)

        # Auto-save to cache if enabled
        if self.use_cache:
            try:
                os.makedirs(self.cache_dir, exist_ok=True)
                sparse.save_npz(cache_file, csr_matrix)
            except Exception:
                # Cache save failed, continue without caching
                pass

        return csr_matrix

    def save_hamiltonian_csr(self, filename: Optional[str] = None) -> str:
        """Save Hamiltonian CSR matrix to cache file.

        Args:
            filename: Custom cache filename. If None, uses default naming.

        Returns:
            str: Path to saved cache file.

        Note:
            Automatically generates CSR matrix if not already available.
        """
        cache_file = self._generate_cache_filename("hamiltonian", filename)

        # Ensure cache directory exists
        os.makedirs(self.cache_dir, exist_ok=True)

        # Get CSR matrix (this will load data if needed)
        csr_matrix = self.get_hamiltonian_csr_U()

        # Save to cache
        sparse.save_npz(cache_file, csr_matrix)

        return cache_file

    def save_overlap_csr(self, filename: Optional[str] = None) -> str:
        """Save overlap CSR matrix to cache file.

        Args:
            filename: Custom cache filename. If None, uses default naming.

        Returns:
            str: Path to saved cache file.

        Note:
            Automatically generates CSR matrix if not already available.
        """
        cache_file = self._generate_cache_filename("overlap", filename)

        # Ensure cache directory exists
        os.makedirs(self.cache_dir, exist_ok=True)

        # Get CSR matrix (this will load data if needed)
        csr_matrix = self.get_overlap_csr_U()

        # Save to cache
        sparse.save_npz(cache_file, csr_matrix)

        return cache_file

    def save_csr_matrices(
        self, hamiltonian_file: Optional[str] = None, overlap_file: Optional[str] = None
    ) -> tuple[str, str]:
        """Save both Hamiltonian and overlap CSR matrices to cache files.

        Args:
            hamiltonian_file: Custom filename for Hamiltonian cache. If None, uses default.
            overlap_file: Custom filename for overlap cache. If None, uses default.

        Returns:
            tuple[str, str]: Paths to saved Hamiltonian and overlap cache files.

        Note:
            Automatically generates CSR matrices if not already available.
        """
        h_cache = self.save_hamiltonian_csr(hamiltonian_file)
        s_cache = self.save_overlap_csr(overlap_file)
        return h_cache, s_cache

    def clear_cache(self) -> int:
        """Remove all cached CSR files for this parser instance.

        Returns:
            int: Number of cache files removed.
        """
        removed_count = 0

        # Find all cache files in cache directory
        cache_pattern = os.path.join(self.cache_dir, "*_csr.npz")

        for cache_file in glob.glob(cache_pattern):
            try:
                os.remove(cache_file)
                removed_count += 1
            except OSError:
                pass

        return removed_count

    def get_cache_info(self) -> dict:
        """Get information about cached CSR files.

        Returns:
            dict: Information about cache files including paths, sizes, and modification times.
        """
        info = {
            "cache_dir": self.cache_dir,
            "use_cache": self.use_cache,
            "hamiltonian_cache": None,
            "overlap_cache": None,
        }

        # Check Hamiltonian cache
        h_cache_file = self._generate_cache_filename("hamiltonian")
        if os.path.exists(h_cache_file):
            stat = os.stat(h_cache_file)
            info["hamiltonian_cache"] = {
                "path": h_cache_file,
                "size_bytes": stat.st_size,
                "modified_time": stat.st_mtime,
                "exists": True,
            }
        else:
            info["hamiltonian_cache"] = {"exists": False}

        # Check overlap cache
        s_cache_file = self._generate_cache_filename("overlap")
        if os.path.exists(s_cache_file):
            stat = os.stat(s_cache_file)
            info["overlap_cache"] = {
                "path": s_cache_file,
                "size_bytes": stat.st_size,
                "modified_time": stat.st_mtime,
                "exists": True,
            }
        else:
            info["overlap_cache"] = {"exists": False}

        return info

    def get_hamiltonian_kspace(self, k_frac: list, return_full: bool = True) -> numpy.ndarray:
        """Get Hamiltonian matrix in k-space for given k-point.

        Performs Fourier transformation from real-space to k-space:
        H(k) = Σ_R H(R) * exp(2πi * k · R)

        Args:
            k_frac: k-vector in fractional Brillouin zone coordinates [k₁, k₂, k₃].
            return_full: If True, return full Hermitian matrix; if False, return U matrix only.
                        Default is True.

        Returns:
            numpy.ndarray: Complex Hamiltonian matrix of shape (n_basis, n_basis).

        Example:
            >>> parser = ParseRSMatrices("path/to/aims/output")
            >>> # Γ-point (mostly real) - full matrix
            >>> H_gamma = parser.get_hamiltonian_kspace([0.0, 0.0, 0.0])
            >>> # Arbitrary k-point (complex) - U matrix only
            >>> H_k_U = parser.get_hamiltonian_kspace([0.5, 0.5, 0.0], return_full=False)
        """
        # Get U matrix using existing method
        U_matrix = self.get_hamiltonian_dense_U()

        # Calculate phase factors
        phase = self._calculate_phase_factors(k_frac)

        # Transform to k-space
        k_matrix = self._fourier_transform_from_U(U_matrix, phase)

        # Return full matrix or just U matrix based on parameter
        if return_full:
            k_matrix[numpy.triu_indices(k_matrix.shape[0], k=1)] = numpy.conj(
                k_matrix.T[numpy.triu_indices(k_matrix.shape[0], k=1)]
            )
        return k_matrix

    def get_overlap_kspace(self, k_frac: list, return_full: bool = True) -> numpy.ndarray:
        """Get overlap matrix in k-space for given k-point.

        Performs Fourier transformation from real-space to k-space:
        S(k) = Σ_R S(R) * exp(2πi * k · R)

        Args:
            k_frac: k-vector in fractional Brillouin zone coordinates [k₁, k₂, k₃].
            return_full: If True, return full Hermitian matrix; if False, return U matrix only.
                        Default is True.

        Returns:
            numpy.ndarray: Complex overlap matrix of shape (n_basis, n_basis).

        Example:
            >>> parser = ParseRSMatrices("path/to/aims/output")
            >>> # Γ-point (mostly real) - full matrix
            >>> S_gamma = parser.get_overlap_kspace([0.0, 0.0, 0.0])
            >>> # Arbitrary k-point (complex) - U matrix only
            >>> S_k_U = parser.get_overlap_kspace([0.5, 0.5, 0.0], return_full=False)
        """
        # Get U matrix using existing method
        U_matrix = self.get_overlap_dense_U()

        # Calculate phase factors
        phase = self._calculate_phase_factors(k_frac)

        # Transform to k-space
        k_matrix = self._fourier_transform_from_U(U_matrix, phase)

        # Return full matrix or just U matrix based on parameter
        if return_full:
            k_matrix[numpy.triu_indices(k_matrix.shape[0], k=1)] = numpy.conj(
                k_matrix.T[numpy.triu_indices(k_matrix.shape[0], k=1)]
            )
        return k_matrix


class ParseHSMatrices:
    """Parser for FHI-aims Hamiltonian and overlap matrices from output_h_s_matrices tag.

    This class handles loading and processing of gamma-point Hamiltonian and overlap
    matrices generated by FHI-aims with the output_h_s_matrices tag. These matrices
    are stored as coordinate-value pairs in text format (hamiltonian.out and
    overlap-matrix.out files).

    Example:
    ```python
    hs_parser = ParseHSMatrices()
    hamiltonian = hs_parser.get_gamma_hamiltonian_matrix("path/to/aims/output")
    overlap = hs_parser.get_gamma_overlap_matrix("path/to/aims/output")
    ```
    """

    @classmethod
    def parse_gamma_matrix(cls, file_path: str, n_basis: Optional[int] = None) -> numpy.ndarray:
        """Parse gamma-point matrix from FHI-aims output file.

        Parses a matrix stored as coordinate-value triplets (row, column, value)
        in text format. This is typically used for hamiltonian.out and
        overlap-matrix.out files generated by the output_h_s_matrices tag.

        Args:
            file_path: Path to the matrix file (hamiltonian.out or overlap-matrix.out).
            n_basis: Number of basis functions. If None, auto-determined from file content.

        Returns:
            numpy.ndarray: Full symmetric matrix of shape (n_basis, n_basis).

        Raises:
            FileNotFoundError: If the specified file does not exist.

        Note:
            - Converts from FHI-aims 1-based to Python 0-based indexing
            - Assumes symmetric matrices and fills both triangular parts
            - Matrix size is auto-determined from maximum row/column indices if n_basis is None
            - Uses vectorized NumPy operations for optimal performance
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Matrix file not found: {file_path}")

        # Load the 3-column data: row_idx, col_idx, value
        data = numpy.loadtxt(file_path)

        # Convert to 0-based indexing (FHI-aims uses 1-based)
        row_indices = data[:, 0].astype(int) - 1
        col_indices = data[:, 1].astype(int) - 1
        values = data[:, 2]

        # Auto-determine matrix size if not provided
        if n_basis is None:
            n_basis = max(numpy.max(row_indices), numpy.max(col_indices)) + 1

        # Create full matrix
        matrix = numpy.zeros((n_basis, n_basis), dtype=numpy.float64)

        # Fill matrix elements using vectorized operations
        matrix[row_indices, col_indices] = values

        # For symmetric matrices, fill both triangular parts using vectorized operations
        # Only fill off-diagonal elements (where i != j) to avoid overwriting diagonal
        off_diagonal_mask = row_indices != col_indices
        matrix[col_indices[off_diagonal_mask], row_indices[off_diagonal_mask]] = values[off_diagonal_mask]

        return matrix

    @classmethod
    def get_gamma_hamiltonian_matrix(cls, test_data_dir: str) -> numpy.ndarray:
        """Get gamma-point Hamiltonian matrix from test data directory.

        Args:
            test_data_dir: Path to directory containing hamiltonian.out file.

        Returns:
            numpy.ndarray: Hamiltonian matrix at gamma point.
        """
        hamiltonian_file = os.path.join(test_data_dir, "hamiltonian.out")
        return cls.parse_gamma_matrix(hamiltonian_file)

    @classmethod
    def get_gamma_overlap_matrix(cls, test_data_dir: str) -> numpy.ndarray:
        """Get gamma-point overlap matrix from test data directory.

        Args:
            test_data_dir: Path to directory containing overlap-matrix.out file.

        Returns:
            numpy.ndarray: Overlap matrix at gamma point.
        """
        overlap_file = os.path.join(test_data_dir, "overlap-matrix.out")
        return cls.parse_gamma_matrix(overlap_file)
